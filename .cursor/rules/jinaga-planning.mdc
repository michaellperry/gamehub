---
description: "Use this rule when creating implementation plans for new Jinaga features. Contains the recommended order of steps, architectural decisions, and planning guidance."
alwaysApply: false
---
# Jinaga Planning and Architecture

## Recommended Implementation Order for Plans

When creating implementation plans for new Jinaga features, follow this order to ensure each step builds upon the decisions made in previous steps:

### 1. Define Facts
Start by defining the immutable facts that represent your domain concepts. Focus on:
- **Core entities** and their relationships
- **Business events** as immutable facts
- **Minimal state** - avoid storing derived data
- **Query-ready design** - structure facts to support intended queries

### 2. Build the User Interface
Create the React components that users will interact with. This helps identify:
- **User workflows** and interaction patterns
- **Data requirements** for each UI component
- **Real-time update needs** for live data synchronization
- **Error handling** and loading state requirements

### 3. Define Custom Hooks and View Models
Create custom hooks that encapsulate business logic and provide view models to components. This reveals:
- **Data access patterns** needed by the UI
- **Command patterns** for user actions
- **State management** requirements
- **Error handling** and loading state logic

### 4. Define Specifications for Querying Facts
Based on the custom hooks, define the specifications needed to query facts:
- **Query patterns** that match UI requirements
- **Parameter requirements** for conditional loading
- **Real-time update** specifications
- **Performance considerations** for data access

### 5. Define Authorization Rules Based on Commands
Analyze the commands in custom hooks to determine who can create each fact type:
- **User actions** that create facts
- **Business rules** for who can perform actions
- **Role-based permissions** for different user types
- **Multi-tenant security** requirements

### 6. Define Distribution Rules Based on Specifications
Design distribution rules that enable the specifications used in custom hooks:
- **Share clauses** that match query specifications
- **With clauses** that define who can execute queries
- **Performance optimization** through targeted distribution
- **Privacy controls** for sensitive data

### 7. Generate Policies
Build and generate the security policies to validate the rules:
- **Policy compilation** to catch rule errors
- **Rule validation** against business requirements
- **Distribution verification** for query enablement
- **Authorization testing** for security compliance

### 8. Write Tests of Custom Hooks
Test the custom hooks using the authorization and distribution rules:
- **Test harness setup** with proper authorization rules
- **Distribution rule testing** for query access
- **Integration testing** with real fact creation
- **Error scenario testing** for edge cases

### Why This Order Matters

Each step relies upon decisions made in previous steps:
- **UI design** reveals what data users need to see and modify
- **Custom hooks** identify the exact queries and commands needed
- **Specifications** must match the query patterns used in hooks
- **Authorization rules** must allow the commands used in hooks
- **Distribution rules** must enable the specifications used in hooks
- **Tests** validate that the entire system works together

This order ensures that your Jinaga model supports the actual user workflows rather than creating a model that doesn't match user needs.

## Planning Considerations

### Common Planning Mistakes

1. **Starting with Authorization/Distribution**: Don't define security rules before understanding what users need to do
2. **Ignoring UI Requirements**: Don't design facts without considering how they'll be used in the interface
3. **Over-engineering Facts**: Don't add complexity to facts before understanding the actual query patterns
4. **Skipping Custom Hooks**: Don't jump directly from UI to specifications without the intermediate step
5. **Testing Last**: Don't leave testing until the end - it should validate each step

### Integration with Other Rules

- **jinaga-facts**: Use after defining facts to implement them
- **jinaga-authorization**: Use after custom hooks to create security rules
- **jinaga-distribution**: Use after specifications to enable queries
- **jinaga-react-hooks**: Use after planning to implement the UI
- **jinaga-testing**: Use throughout to validate each step

### Planning Checklist

- [ ] Facts support intended user workflows
- [ ] UI components have clear data requirements
- [ ] Custom hooks encapsulate business logic
- [ ] Specifications match hook requirements
- [ ] Authorization rules allow hook commands
- [ ] Distribution rules enable hook specifications
- [ ] Policies validate all rules
- [ ] Tests verify entire system works 
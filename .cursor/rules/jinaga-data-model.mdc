---
description: "GameHub Jinaga data model development standards for creating immutable facts, authorization rules, and distribution patterns in the event-sourced architecture. Includes fact definition patterns, multi-tenant structures, role-based authorization, hierarchical permissions, share/with distribution rules, client-side React hooks with useSpecification, server-side querying patterns, and best practices for immutable fact design, security, and performance optimization."
alwaysApply: false
---
# Jinaga Data Model Development

## Model Architecture (`app/gamehub-model/`)

### Core Structure
- **[index.ts](app/gamehub-model/index.ts)** - Main exports and model entry point
- **[model/](app/gamehub-model/model/)** - Fact definitions and domain model
- **[authorization/](app/gamehub-model/authorization/)** - Security rules and policies
- **[distribution/](app/gamehub-model/distribution/)** - Fact distribution logic using `share`/`with` pattern

## Fact Definition Patterns

### Basic Fact Structure
```typescript
// app/gamehub-model/model/my-fact.ts
import { LabelOf, ModelBuilder, User } from 'jinaga';

export class MyFact {
  static Type = 'MyFact' as const;
  public type = MyFact.Type;
  
  constructor(
    public readonly property: string,
    public readonly createdBy: User
  ) {}
}

// Model registration
export const myFactModel = (b: ModelBuilder) =>
  b.type(MyFact, (m) => m.predecessor('createdBy', User));
```

### Fact Relationships
```typescript
// Facts with references to other facts
import { LabelOf, ModelBuilder, User } from 'jinaga';

export class GameSession {
  static Type = 'GameSession' as const;
  public type = GameSession.Type;
  
  constructor(
    public readonly game: Game,
    public readonly createdBy: User
  ) {}
}

export class PlayerMove {
  static Type = 'PlayerMove' as const;
  public type = PlayerMove.Type;
  
  constructor(
    public readonly session: GameSession,
    public readonly move: string,
    public readonly madeBy: User
  ) {}
}

// Model registration with relationships
export const gameModel = (b: ModelBuilder) =>
  b
    .type(GameSession, (m) => m.predecessor('game', Game).predecessor('createdBy', User))
    .type(PlayerMove, (m) => m.predecessor('session', GameSession).predecessor('madeBy', User));
```

### Multi-tenant Facts
```typescript
// Facts that belong to specific organizations
import { LabelOf, ModelBuilder, User } from 'jinaga';

export class Tenant {
  static Type = 'GameHub.Tenant' as const;
  public type = Tenant.Type;

  constructor(public creator: User) {}
}

export class Administrator {
  static Type = 'GameHub.Tenant.Administrator' as const;
  public type = Administrator.Type;

  constructor(
    public tenant: Tenant,
    public user: User,
    public createdAt: Date | string
  ) {}

  static of(tenant: LabelOf<Tenant>) {
    return tenant.successors(Administrator, (admin) => admin.tenant);
  }

  static by(user: LabelOf<User>) {
    return user.successors(Administrator, (admin) => admin.user);
  }

  static usersOf(tenant: LabelOf<Tenant>) {
    return tenant
      .successors(Administrator, (admin) => admin.tenant)
      .selectMany((admin) => admin.user.predecessor());
  }
}

// Model registration
export const tenantModel = (b: ModelBuilder) =>
  b
    .type(Tenant, (m) => m.predecessor('creator', User))
    .type(Administrator, (m) => m.predecessor('tenant', Tenant).predecessor('user', User));
```

## Authorization Rules (`app/gamehub-model/authorization/`)

### Basic Authorization
```typescript
// app/gamehub-model/authorization/tenantAuthorization.ts
import { AuthorizationRules } from 'jinaga';
import { Administrator, Tenant } from '../model/index.js';

export const tenantAuthorization = (a: AuthorizationRules) =>
  a
    // Only the creator can create a tenant
    .type(Tenant, (tenant) => tenant.creator.predecessor())

    // The creator of a tenant can create administrators for that tenant
    .type(Administrator, (admin) => admin.tenant.creator.predecessor())

    // Administrators can add other administrators to their tenant
    .type(Administrator, (admin) => Administrator.usersOf(admin.tenant));
```

### Role-based Authorization
```typescript
// Authorization based on user roles
import { AuthorizationRules } from 'jinaga';
import { Administrator, Tenant } from '../model/index.js';

export const adminAuthorization = (a: AuthorizationRules) =>
  a
    // Only administrators can access admin-only facts
    .type(AdminOnlyFact, (fact) => 
      Administrator.usersOf(fact.tenant)
    )

    // Administrators can manage their own tenant
    .type(TenantManagement, (management) => 
      Administrator.usersOf(management.tenant)
    );
```

### Hierarchical Authorization
```typescript
// Facts that inherit permissions from parent facts
import { AuthorizationRules } from 'jinaga';
import { Administrator, Tenant, Player } from '../model/index.js';

export const hierarchicalAuthorization = (a: AuthorizationRules) =>
  a
    // Players can access facts within their tenant
    .type(PlayerFact, (fact) => 
      Player.in(fact.tenant)
    )

    // Administrators can access all facts in their tenant
    .type(AnyTenantFact, (fact) => 
      Administrator.usersOf(fact.tenant)
    );
```

## Distribution Rules (`app/gamehub-model/distribution/`)

Distribution rules use the `share`/`with` pattern to control how facts are distributed across users and services. The `share` clause defines what facts to share, and the `with` clause defines who receives them.

### Fact Distribution
```typescript
// app/gamehub-model/distribution/tenantDistribution.ts
import { DistributionRules, User } from 'jinaga';
import { Administrator, model, Tenant } from '../model/index.js';

export const tenantDistribution = (r: DistributionRules) =>
  r
    // Share tenant administrators with other administrators
    .share(
      model
        .given(Tenant, User)
        .match((tenant, user) => Administrator.of(tenant).join((admin) => admin.user, user))
    )
    .with(model.given(Tenant, User).match((tenant, user) => Administrator.usersOf(tenant)))

    // Share tenants of administrator with the user
    .share(
      model.given(User).match((user) =>
        Administrator.by(user)
          .selectMany((admin) => admin.tenant.predecessor())
          .selectMany((tenant) => tenant.creator.predecessor())
      )
    )
    .with(model.given(User).match((user) => user.predecessor()));
```

### Selective Distribution
```typescript
// Distribute facts only to specific users or contexts
import { DistributionRules, User } from 'jinaga';
import { model, Tenant, Player } from '../model/index.js';

export const selectiveDistribution = (r: DistributionRules) =>
  r
    // Share player facts only with the player's tenant
    .share(
      model
        .given(Player)
        .match((player) => player.tenant.predecessor())
    )
    .with(model.given(Tenant).match((tenant) => Player.in(tenant)))

    // Share private facts only with the creator
    .share(
      model
        .given(PrivateFact)
        .match((fact) => fact.createdBy.predecessor())
    )
    .with(model.given(User).match((user) => user.predecessor()));
```

## Model Usage Patterns

### Client-side Usage
```typescript
// In React components
import { model, ServicePrincipal, Tenant } from '@model/model';
import { User } from 'jinaga';
import { useSpecification } from 'jinaga-react';
import { useState } from 'react';
import { j } from '../jinaga-config';
import { useTenant } from '../tenants/useTenant';

// Define specification for querying facts
const servicePrincipalsInTenant = model
  .given(Tenant)
  .match((tenant) => ServicePrincipal.of(tenant));

// Create facts using fact method
async function createServicePrincipal(tenant: Tenant, publicKey: string) {
  await j.fact(new ServicePrincipal(new User(publicKey), tenant, new Date()));
}

async function createTenant(user: User) {
  const tenant = await j.fact(new Tenant(user));
  await j.fact(new Administrator(tenant, user, new Date()));
}

// React hook using useSpecification
export function useServicePrincipals() {
  const tenant = useTenant();
  const { data, error, loading } = useSpecification(j, servicePrincipalsInTenant, tenant);
  const [actionError, setActionError] = useState<Error | null>(null);

  const addServicePrincipal = (publicKey: string) => {
    if (tenant) {
      createServicePrincipal(tenant, publicKey)
        .then(() => setActionError(null))
        .catch(setActionError);
    }
  };

  return {
    isConfigured: !!tenant,
    servicePrincipals: data?.map((sp) => ({
      id: j.hash(sp),
      createdAt: sp.createdAt,
      publicKey: sp.user.publicKey,
    })) || null,
    error: actionError || error,
    loading: loading,
    canAddServicePrincipal: !!tenant,
    addServicePrincipal,
  };
}
```

### Client-side Usage - useSpecification Best Practices
```typescript
// Correct pattern for useSpecification with conditional parameters
export function useConditionalData() {
  const user = useUser();
  const tenant = useTenant();
  
  // Define specification that expects both parameters
  const dataSpec = model.given(User, Tenant).match((user, tenant) => 
    SomeFact.in(tenant).join(fact => fact.user, user)
  );
  
  // Pass null parameters - useSpecification will only load when all are non-null
  const { data, loading } = useSpecification(j, dataSpec, user, tenant);
  
  return { data, loading };
}
```

### Common Mistakes to Avoid
```typescript
// ❌ WRONG: Creating fallback objects
const { data } = useSpecification(j, spec, user || new User(''), tenant || new Tenant(new User('')));

// ❌ WRONG: Conditional specification creation
const spec = user && tenant ? model.given(User, Tenant).match(...) : null;

// ✅ CORRECT: Always define the specification, let useSpecification handle nulls
const spec = model.given(User, Tenant).match((user, tenant) => ...);
const { data } = useSpecification(j, spec, user, tenant);
```

### Specification Definition Patterns
```typescript
// ✅ CORRECT: Define specification once, use with conditional parameters
const playerNameSpec = model.given(User, Tenant).match((user, tenant) => 
  Player.in(tenant)
    .join(player => player.user, user)
    .selectMany(player => PlayerName.current(player))
);

// ✅ CORRECT: Pass actual parameters (including null)
const { data } = useSpecification(j, playerNameSpec, user, tenant);
```

### Server-side Usage
```typescript
// In backend services
import { Jinaga } from 'jinaga';
import { Game, GameSession, PlayerMove, Tenant, model } from '@gamehub/model';

const jinaga = new Jinaga();

// Define specifications for querying
const gamesSpec = model.given(User).match((user) => 
  Game.of(user).select(game => ({
    id: game.hash,
    name: game.name,
    type: game.gameType
  }))
);

// Query facts using specifications
const games = await jinaga.query(gamesSpec, user);

// Observe facts with specifications
const observer = jinaga.watch(gamesSpec, user, (game) => {
  console.log('Active game:', game);
});

// Store new facts using fact method
const game = await jinaga.fact(new Game(tenant, 'Chess Game', 'chess', user));
const session = await jinaga.fact(new GameSession(game, user));
```

## Best Practices

### Fact Design
1. **Immutable**: Facts should be immutable once created
2. **Referential**: Use references to other facts for relationships
3. **Hierarchical**: Structure facts in logical hierarchies

### Authorization Design
1. **Principle of Least Privilege**: Grant minimal necessary access
2. **Role-based**: Use roles for complex permission scenarios
3. **Inheritance**: Child facts inherit parent permissions
4. **Explicit**: Make authorization rules explicit and testable

### useSpecification Parameter Handling
1. **Never create fallback objects**: Don't create dummy User/Tenant objects when parameters are null
2. **Let useSpecification handle nulls**: The hook automatically waits for all parameters to be non-null
3. **Define specifications unconditionally**: Always define the full specification, don't conditionally create it
4. **Trust the loading state**: The `loading` flag properly indicates when data is being fetched

### Loading State Management
1. **Automatic loading detection**: `useSpecification` automatically sets `loading: true` when parameters are null
2. **No manual loading logic**: Don't manually track loading states for parameter availability
3. **Real-time updates**: The hook automatically re-runs when parameters change from null to non-null
4. **Loading flag vs Data availability**: 
   - `loading: true` → Show loading indicator in UI
   - `data !== null` → Data has been loaded (may be empty array)
   - `data === null` → Still loading or error occurred
5. **Check data, not loading**: Use `data !== null` to determine if data is available, not the loading flag

### Error Handling
```typescript
// ✅ CORRECT: Handle errors from useSpecification
const { data, error, loading } = useSpecification(j, spec, user, tenant);

// ✅ CORRECT: Check for parameter availability before actions
const handleAction = async () => {
  if (!user || !tenant) {
    console.error('Required parameters not available');
    return;
  }
  // Proceed with action
};
```

### Performance Considerations
1. **Indexing**: Use appropriate fact types for efficient queries
2. **Distribution**: Minimize unnecessary fact distribution
3. **Caching**: Cache frequently accessed facts on the client
4. **Pagination**: Handle large fact sets with pagination

---
description: "Apply this rule when defining new fact types, authorization rules, or distribution patterns in the Jinaga data model. Use for creating immutable facts, multi-tenant structures, role-based authorization, and share/with distribution rules."
alwaysApply: false
---
# Jinaga Data Model Development

## Related Rules

- **jinaga-usage-patterns**: Use this rule when you need to load or create facts from React components
- **frontend-development**: Use this rule when implementing UI components that interact with facts

## When to Use Both Rules Together

When building UI components that create new facts:
1. **First**: Use **jinaga-data-model** to define the fact structure, authorization, and distribution rules
2. **Then**: Use **jinaga-usage-patterns** to implement the React components that create and display those facts

## Model Architecture (`app/gamehub-model/`)

### Core Structure
- **[index.ts](app/gamehub-model/index.ts)** - Main exports and model entry point
- **[model/](app/gamehub-model/model/)** - Fact definitions and domain model
- **[authorization/](app/gamehub-model/authorization/)** - Security rules and policies
- **[distribution/](app/gamehub-model/distribution/)** - Query execution control using `share`/`with` pattern

## Fact Definition Patterns

### Basic Fact Structure
```typescript
// app/gamehub-model/model/my-fact.ts
import { LabelOf, ModelBuilder, User } from 'jinaga';

export class MyFact {
  static Type = 'MyFact' as const;
  public type = MyFact.Type;
  
  constructor(
    public readonly property: string,
    public readonly createdBy: User
  ) {}
}

// Model registration
export const myFactModel = (b: ModelBuilder) =>
  b.type(MyFact, (m) => m.predecessor('createdBy', User));
```

### Fact Relationships
```typescript
// Facts with references to other facts
import { LabelOf, ModelBuilder, User } from 'jinaga';

export class GameSession {
  static Type = 'GameSession' as const;
  public type = GameSession.Type;
  
  constructor(
    public readonly game: Game,
    public readonly createdBy: User
  ) {}
}

export class PlayerMove {
  static Type = 'PlayerMove' as const;
  public type = PlayerMove.Type;
  
  constructor(
    public readonly session: GameSession,
    public readonly move: string,
    public readonly madeBy: User
  ) {}
}

// Model registration with relationships
export const gameModel = (b: ModelBuilder) =>
  b
    .type(GameSession, (m) => m.predecessor('game', Game).predecessor('createdBy', User))
    .type(PlayerMove, (m) => m.predecessor('session', GameSession).predecessor('madeBy', User));
```

### Static Helper Functions for Query Patterns
```typescript
// Create reusable query patterns as static methods
export class Challenge {
  // ... existing constructor and properties ...

  // Helper for distribution rules - challenges where player is challenger
  static whereChallenger(player: LabelOf<Player>) {
    return Join.by(player)
      .selectMany((join) => join.successors(Challenge, (challenge) => challenge.challengerJoin));
  }

  // Helper for distribution rules - challenges where player is opponent  
  static whereOpponent(player: LabelOf<Player>) {
    return Join.by(player)
      .selectMany((join) => join.successors(Challenge, (challenge) => challenge.opponentJoin));
  }
}
```

**Benefits:**
- Makes distribution rules more readable and maintainable
- Centralizes complex query logic in the model classes
- Enables reuse across different authorization and distribution contexts
- Follows established naming conventions: `whereX()`, `by()`, `in()`

### Multi-tenant Facts
```typescript
// Facts that belong to specific organizations
import { LabelOf, ModelBuilder, User } from 'jinaga';

export class Tenant {
  static Type = 'GameHub.Tenant' as const;
  public type = Tenant.Type;

  constructor(public creator: User) {}
}

export class Administrator {
  static Type = 'GameHub.Tenant.Administrator' as const;
  public type = Administrator.Type;

  constructor(
    public tenant: Tenant,
    public user: User,
    public createdAt: Date | string
  ) {}

  static of(tenant: LabelOf<Tenant>) {
    return tenant.successors(Administrator, (admin) => admin.tenant);
  }

  static by(user: LabelOf<User>) {
    return user.successors(Administrator, (admin) => admin.user);
  }

  static usersOf(tenant: LabelOf<Tenant>) {
    return tenant
      .successors(Administrator, (admin) => admin.tenant)
      .selectMany((admin) => admin.user.predecessor());
  }
}

// Model registration
export const tenantModel = (b: ModelBuilder) =>
  b
    .type(Tenant, (m) => m.predecessor('creator', User))
    .type(Administrator, (m) => m.predecessor('tenant', Tenant).predecessor('user', User));
```

## Fact Design Principles

### Keep Facts Simple
```typescript
// ✅ CORRECT: Focus on relationships
export class Game {
  constructor(public challenge: Challenge) { }
}

// ❌ WRONG: Store derived state
export class Game {
  constructor(
    public challenge: Challenge,
    public gameState: string,
    public currentTurn: string,
    public board: string,
    public createdAt: Date | string
  ) { }
}
```

### Design Principles
1. **Immutable**: Facts never change once created
2. **Relationship-Focused**: Use references to other facts
3. **Minimal State**: Avoid storing derived or computed data
4. **Query-Ready**: Design facts to support intended queries
5. **Business Logic**: Reflect actual business processes and workflows

### When to Add Fields
- **Required for business logic**: Add fields that represent core relationships
- **Avoid derived data**: Don't store what can be computed from predecessors
- **Consider queries**: Add fields that support common query patterns
- **Keep it minimal**: Start simple, add complexity only when needed

## Authorization Rules (`app/gamehub-model/authorization/`)

### Basic Authorization
```typescript
// app/gamehub-model/authorization/tenantAuthorization.ts
import { AuthorizationRules } from 'jinaga';
import { Administrator, Tenant } from '../model/index.js';

export const tenantAuthorization = (a: AuthorizationRules) =>
  a
    // Only the creator can create a tenant
    .type(Tenant, (tenant) => tenant.creator.predecessor())

    // The creator of a tenant can create administrators for that tenant
    .type(Administrator, (admin) => admin.tenant.creator.predecessor())

    // Administrators can add other administrators to their tenant
    .type(Administrator, (admin) => Administrator.usersOf(admin.tenant));
```

### Authorization Rule Best Practices

#### Keep Authorization Simple
```typescript
// ✅ CORRECT: Direct user reference
.type(Challenge, (challenge) => challenge.challengerJoin.player.user.predecessor())

// ❌ WRONG: Complex joins that don't resolve to LabelOf<User>
.type(Challenge, (challenge) => challenge.challengerJoin.join(...))
```

#### Authorization vs Distribution
- **Authorization**: "Who can create this fact?" → Returns `LabelOf<User>`
- **Distribution**: "Who can run this query?" → Uses `share`/`with` pattern
- Keep authorization rules simple and direct
- Avoid complex joins in authorization - put complexity in distribution rules

### Role-based Authorization
```typescript
// Authorization based on user roles
import { AuthorizationRules } from 'jinaga';
import { Administrator, Tenant } from '../model/index.js';

export const adminAuthorization = (a: AuthorizationRules) =>
  a
    // Only administrators can access admin-only facts
    .type(AdminOnlyFact, (fact) => 
      Administrator.usersOf(fact.tenant)
    )

    // Administrators can manage their own tenant
    .type(TenantManagement, (management) => 
      Administrator.usersOf(management.tenant)
    );
```

## Query-Driven Distribution Design

### Design for Actual User Queries
Before writing distribution rules, identify the queries users will actually execute:

```typescript
// What queries will players execute?
const myChallenges = Challenge.whereChallenger(currentPlayer);
const incomingChallenges = Challenge.whereOpponent(currentPlayer);
const myGames = Game.whereChallenger(currentPlayer);
```

### Distribution Rule Design Process
1. **Identify User Queries**: What queries do users need to execute?
2. **Design Share Clause**: Enable those specific queries
3. **Design With Clause**: Define who can execute those queries
4. **Keep Share Simple**: Avoid complex joins in share clause

### Example: Player-Centric Distribution
```typescript
// ✅ CORRECT: Enable specific user queries
.share(model.given(Player).match((player) => Challenge.whereChallenger(player)))
.with(model.given(Player).match((player) => player.predecessor()))

// ❌ WRONG: Share everything with playground
.share(model.given(Playground).match((playground) => Challenge.for(playground)))
```

### Benefits of Query-Driven Design
- **Performance**: Only distribute necessary data
- **Privacy**: Users only see what they need
- **Simplicity**: Queries match user mental models
- **Maintainability**: Rules reflect actual usage patterns

## Distribution Rules (`app/gamehub-model/distribution/`)

Distribution rules use the `share`/`with` pattern to control what queries users can execute. The `share` clause defines the query structure that users are allowed to run, and the `with` clause defines who can execute those queries.

### Distribution Rule Patterns (`share`/`with`)

#### Basic Share/With Pattern
```typescript
// CORRECT: Simple share/with pattern
.share(
  model.given(Tenant).match((tenant) => SomeFact.in(tenant))
)
.with(model.given(Tenant).match((tenant) => 
  Player.in(tenant).selectMany((player) => player.user.predecessor())
));

// This enables users to execute queries like:
const factsSpec = model.given(Tenant).match((tenant) => SomeFact.in(tenant));
const facts = await jinaga.query(factsSpec, tenant);
```

#### Common Mistakes to Avoid
```typescript
// ❌ WRONG: Share everything with playground
.share(model.given(Playground).match((playground) => Challenge.for(playground)))

// ✅ RIGHT: Share only with participants  
.share(model.given(Player).match((player) => Challenge.whereChallenger(player)))
```

#### Rule of Thumb
- `share` clause: Define WHAT queries users can execute (keep simple)
- `with` clause: Define WHO can execute those queries (can be complex)
- The share clause should match the structure of queries you want users to write
- Avoid complex joins in the `share` clause as they force complex user queries
- Use `selectMany` and `predecessor()` in the `with` clause for user traversal

### Why Simple Share Clauses Matter

Complex share clauses force users to write complex queries, which:
- Reduces usability for simple use cases
- Increases complexity for frontend developers
- Makes the API harder to understand and debug
- Can cause performance issues with unnecessary joins
- Creates barriers to adoption

The goal is to enable users to write intuitive, simple queries that match their mental model of the data.

### Common Distribution Patterns

#### Enable Queries for Specific Participants
```typescript
.share(
  model.given(Player).match((player) => Challenge.whereChallenger(player))
)
.with(model.given(Player).match((player) => player.predecessor()));

// Users can execute:
const challengesSpec = model.given(Player).match((player) => Challenge.whereChallenger(player));
const challenges = await jinaga.query(challengesSpec, currentPlayer);
```

#### Enable Queries for Administrators Only
```typescript
.share(
  model.given(Tenant).match((tenant) => AdminFact.in(tenant))
)
.with(model.given(Tenant).match((tenant) => 
  Administrator.usersOf(tenant)
));

// Administrators can execute:
const adminFactsSpec = model.given(Tenant).match((tenant) => AdminFact.in(tenant));
const adminFacts = await jinaga.query(adminFactsSpec, tenant);
```

## Validation and Testing

### Build and Policy Generation
```bash
# Always build after changes
npm run build

# Generate policies to verify rules
npm run generate-policies

# Check policy file for correct rule generation
cat mesh/replicator/policies/gamehub.policy
```

### Validation Checklist
- [ ] Authorization rules compile without TypeScript errors
- [ ] Distribution rules follow `share`/`with` pattern
- [ ] Static helpers are reusable across contexts
- [ ] Policy file contains expected rule entries
- [ ] Facts support intended query patterns
- [ ] Rules match business logic requirements

### Common Issues
1. **Authorization Errors**: Ensure rules return `LabelOf<User>`
2. **Distribution Complexity**: Keep share clauses simple
3. **Missing Imports**: Import all referenced fact types
4. **Policy Generation**: Verify rules appear in generated policy

## Best Practices

### Model Design
1. **Query-First**: Design facts around actual user queries
2. **Static Helpers**: Create reusable query patterns
3. **Simple Authorization**: Keep authorization rules direct and simple
4. **Targeted Distribution**: Share only necessary data
5. **Business Logic**: Reflect actual workflows and processes

### Development Workflow
1. **Build Continuously**: Run `npm run build` after each change
2. **Generate Policies**: Verify rules with `npm run generate-policies`
3. **Test Queries**: Ensure intended queries work as expected
4. **Iterate**: Refactor based on actual usage patterns

### Fact Design
1. **Immutable**: Facts should be immutable once created
2. **Referential**: Use references to other facts for relationships
3. **Hierarchical**: Structure facts in logical hierarchies

### Authorization Design
1. **Keep it Simple**: Authorization rules should return `LabelOf<User>` directly
2. **Direct References**: Use direct predecessor relationships when possible
3. **Avoid Complex Joins**: Put complex logic in distribution rules, not authorization
4. **Test Continuously**: Build and generate policies after each change

2. **Distribution**: Minimize unnecessary query complexity
3. **Caching**: Cache frequently accessed facts on the client
4. **Pagination**: Handle large fact sets with pagination

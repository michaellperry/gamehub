---
description: "Apply this rule whenever designing new persistent data types, or modifying the security rules for existing persistent data types. GameHub Jinaga data model development standards for creating immutable facts, authorization rules, and distribution patterns in the event-sourced architecture. Includes fact definition patterns, multi-tenant structures, role-based authorization, hierarchical permissions, share/with distribution rules, and best practices for immutable fact design, security, and performance optimization."
alwaysApply: false
---
# Jinaga Data Model Development

## Model Architecture (`app/gamehub-model/`)

### Core Structure
- **[index.ts](app/gamehub-model/index.ts)** - Main exports and model entry point
- **[model/](app/gamehub-model/model/)** - Fact definitions and domain model
- **[authorization/](app/gamehub-model/authorization/)** - Security rules and policies
- **[distribution/](app/gamehub-model/distribution/)** - Fact distribution logic using `share`/`with` pattern

## Fact Definition Patterns

### Basic Fact Structure
```typescript
// app/gamehub-model/model/my-fact.ts
import { LabelOf, ModelBuilder, User } from 'jinaga';

export class MyFact {
  static Type = 'MyFact' as const;
  public type = MyFact.Type;
  
  constructor(
    public readonly property: string,
    public readonly createdBy: User
  ) {}
}

// Model registration
export const myFactModel = (b: ModelBuilder) =>
  b.type(MyFact, (m) => m.predecessor('createdBy', User));
```

### Fact Relationships
```typescript
// Facts with references to other facts
import { LabelOf, ModelBuilder, User } from 'jinaga';

export class GameSession {
  static Type = 'GameSession' as const;
  public type = GameSession.Type;
  
  constructor(
    public readonly game: Game,
    public readonly createdBy: User
  ) {}
}

export class PlayerMove {
  static Type = 'PlayerMove' as const;
  public type = PlayerMove.Type;
  
  constructor(
    public readonly session: GameSession,
    public readonly move: string,
    public readonly madeBy: User
  ) {}
}

// Model registration with relationships
export const gameModel = (b: ModelBuilder) =>
  b
    .type(GameSession, (m) => m.predecessor('game', Game).predecessor('createdBy', User))
    .type(PlayerMove, (m) => m.predecessor('session', GameSession).predecessor('madeBy', User));
```

### Multi-tenant Facts
```typescript
// Facts that belong to specific organizations
import { LabelOf, ModelBuilder, User } from 'jinaga';

export class Tenant {
  static Type = 'GameHub.Tenant' as const;
  public type = Tenant.Type;

  constructor(public creator: User) {}
}

export class Administrator {
  static Type = 'GameHub.Tenant.Administrator' as const;
  public type = Administrator.Type;

  constructor(
    public tenant: Tenant,
    public user: User,
    public createdAt: Date | string
  ) {}

  static of(tenant: LabelOf<Tenant>) {
    return tenant.successors(Administrator, (admin) => admin.tenant);
  }

  static by(user: LabelOf<User>) {
    return user.successors(Administrator, (admin) => admin.user);
  }

  static usersOf(tenant: LabelOf<Tenant>) {
    return tenant
      .successors(Administrator, (admin) => admin.tenant)
      .selectMany((admin) => admin.user.predecessor());
  }
}

// Model registration
export const tenantModel = (b: ModelBuilder) =>
  b
    .type(Tenant, (m) => m.predecessor('creator', User))
    .type(Administrator, (m) => m.predecessor('tenant', Tenant).predecessor('user', User));
```

## Authorization Rules (`app/gamehub-model/authorization/`)

### Basic Authorization
```typescript
// app/gamehub-model/authorization/tenantAuthorization.ts
import { AuthorizationRules } from 'jinaga';
import { Administrator, Tenant } from '../model/index.js';

export const tenantAuthorization = (a: AuthorizationRules) =>
  a
    // Only the creator can create a tenant
    .type(Tenant, (tenant) => tenant.creator.predecessor())

    // The creator of a tenant can create administrators for that tenant
    .type(Administrator, (admin) => admin.tenant.creator.predecessor())

    // Administrators can add other administrators to their tenant
    .type(Administrator, (admin) => Administrator.usersOf(admin.tenant));
```

### Role-based Authorization
```typescript
// Authorization based on user roles
import { AuthorizationRules } from 'jinaga';
import { Administrator, Tenant } from '../model/index.js';

export const adminAuthorization = (a: AuthorizationRules) =>
  a
    // Only administrators can access admin-only facts
    .type(AdminOnlyFact, (fact) => 
      Administrator.usersOf(fact.tenant)
    )

    // Administrators can manage their own tenant
    .type(TenantManagement, (management) => 
      Administrator.usersOf(management.tenant)
    );
```

### Hierarchical Authorization
```typescript
// Facts that inherit permissions from parent facts
import { AuthorizationRules } from 'jinaga';
import { Administrator, Tenant, Player } from '../model/index.js';

export const hierarchicalAuthorization = (a: AuthorizationRules) =>
  a
    // Players can access facts within their tenant
    .type(PlayerFact, (fact) => 
      Player.in(fact.tenant)
    )

    // Administrators can access all facts in their tenant
    .type(AnyTenantFact, (fact) => 
      Administrator.usersOf(fact.tenant)
    );
```

## Distribution Rules (`app/gamehub-model/distribution/`)

Distribution rules use the `share`/`with` pattern to control how facts are distributed across users and services. The `share` clause defines what facts to share, and the `with` clause defines who receives them.

### Fact Distribution
```typescript
// app/gamehub-model/distribution/tenantDistribution.ts
import { DistributionRules, User } from 'jinaga';
import { Administrator, model, Tenant } from '../model/index.js';

export const tenantDistribution = (r: DistributionRules) =>
  r
    // Share tenant administrators with other administrators
    .share(
      model
        .given(Tenant, User)
        .match((tenant, user) => Administrator.of(tenant).join((admin) => admin.user, user))
    )
    .with(model.given(Tenant, User).match((tenant, user) => Administrator.usersOf(tenant)))

    // Share tenants of administrator with the user
    .share(
      model.given(User).match((user) =>
        Administrator.by(user)
          .selectMany((admin) => admin.tenant.predecessor())
          .selectMany((tenant) => tenant.creator.predecessor())
      )
    )
    .with(model.given(User).match((user) => user.predecessor()));
```

### Selective Distribution
```typescript
// Distribute facts only to specific users or contexts
import { DistributionRules, User } from 'jinaga';
import { model, Tenant, Player } from '../model/index.js';

export const selectiveDistribution = (r: DistributionRules) =>
  r
    // Share player facts only with the player's tenant
    .share(
      model
        .given(Player)
        .match((player) => player.tenant.predecessor())
    )
    .with(model.given(Tenant).match((tenant) => Player.in(tenant)))

    // Share private facts only with the creator
    .share(
      model
        .given(PrivateFact)
        .match((fact) => fact.createdBy.predecessor())
    )
    .with(model.given(User).match((user) => user.predecessor()));
```



## Best Practices

### Fact Design
1. **Immutable**: Facts should be immutable once created
2. **Referential**: Use references to other facts for relationships
3. **Hierarchical**: Structure facts in logical hierarchies

### Authorization Design
1. **Principle of Least Privilege**: Grant minimal necessary access
2. **Role-based**: Use roles for complex permission scenarios
3. **Inheritance**: Child facts inherit parent permissions
4. **Explicit**: Make authorization rules explicit and testable



### Performance Considerations
1. **Indexing**: Use appropriate fact types for efficient queries
2. **Distribution**: Minimize unnecessary fact distribution
3. **Caching**: Cache frequently accessed facts on the client
4. **Pagination**: Handle large fact sets with pagination
